#!/usr/bin/env python

"""
An interactive audio recorder and transcriber with an optional rewrite step.

Records audio and transcribes it using a selected provider (Groq or OpenAI).
- In interactive mode, it shows a live UI to control recording and options.
- In non-interactive mode, it transcribes a given audio file.
- Optionally rewrites the transcript for clarity and formatting using an LLM.
"""
import os
import shutil
import subprocess
import tempfile
import time
import json
import base64
from dataclasses import dataclass, field
from pathlib import Path

import typer
from rich.console import Console
from rich.text import Text
import platformdirs

from textual.app import App, ComposeResult
from textual.widgets import Footer, Header, Static

from dotenv import load_dotenv

load_dotenv()


# --- Configuration ---
TRANSCRIPTION_PROVIDERS = {
    "groq/whisper-large-v3": {"model": "groq/whisper-large-v3", "api_key_env": "GROQ_API_KEY"},
    "openai/whisper-1": {"model": "openai/whisper-1", "api_key_env": "OPENAI_API_KEY"},
}

REWRITE_PROVIDERS = {
    "groq/llama3-70b": {
        "model": "groq/llama3-70b-8192",
        "supports_images": False,
        "api_key_env": "GROQ_API_KEY",
    },
    "claude-3.5-haiku": {
        "model": "anthropic/claude-3-5-haiku-20241022",
        "supports_images": True,
        "api_key_env": "ANTHROPIC_API_KEY",
    },
    "gpt-4o": {
        "model": "openai/gpt-4o",
        "supports_images": True,
        "api_key_env": "OPENAI_API_KEY",
    },
}


# --- Settings Management ---
def get_settings_path() -> Path:
    """Returns the path to the settings file."""
    settings_dir = platformdirs.user_config_path("2text", ensure_exists=True)
    return settings_dir / "settings.json"


def load_settings() -> dict:
    """Loads settings from the JSON file, returning an empty dict on failure."""
    settings_path = get_settings_path()
    if not settings_path.exists():
        return {}
    try:
        with open(settings_path, "r") as f:
            # Handle empty file case
            content = f.read()
            if not content:
                return {}
            settings = json.loads(content)
            # Validate provider settings
            if "provider" in settings and settings["provider"] not in TRANSCRIPTION_PROVIDERS:
                del settings["provider"]
            if (
                "rewrite_provider" in settings
                and settings["rewrite_provider"] not in REWRITE_PROVIDERS
            ):
                del settings["rewrite_provider"]
            return settings
    except (json.JSONDecodeError, IOError):
        return {}


def save_settings(state: "AppState"):
    """Saves relevant settings from the app state to the JSON file."""
    settings_path = get_settings_path()
    settings_to_save = {
        "provider": state.provider,
        "language": state.language,
        "rewrite_provider": state.rewrite_provider,
    }
    with open(settings_path, "w") as f:
        json.dump(settings_to_save, f, indent=2)


# --- State Management ---
@dataclass
class AppState:
    """Holds the dynamic state of the application."""

    provider: str = next(iter(TRANSCRIPTION_PROVIDERS.keys()))
    rewrite_provider: str = next(iter(REWRITE_PROVIDERS.keys()))
    language: str | None = "auto"
    rewrite: bool = False
    with_context: bool = False
    output_file: Path | None = None
    start_time: float = field(default_factory=time.time)

    @property
    def model_name(self) -> str:
        """Returns the transcription model name based on the provider."""
        return TRANSCRIPTION_PROVIDERS[self.provider]["model"]

    def get_duration(self) -> str:
        """Returns the formatted recording duration."""
        return f"{time.time() - self.start_time:.1f}s"

    def get_file_size_str(self) -> str:
        """Returns the formatted file size as a string."""
        if self.output_file and self.output_file.exists():
            size_bytes = self.output_file.stat().st_size
            if size_bytes < 1024:
                return f"{size_bytes} B"
            elif size_bytes < 1024 * 1024:
                return f"{size_bytes / 1024:.1f} KB"
            else:
                return f"{size_bytes / (1024 * 1024):.1f} MB"
        return "0 B"


class RecordingError(Exception):
    """Exception raised when the recording process fails."""


# --- Textual Application for Interactive Mode ---
LANGUAGES = ["en", "fr", None]  # None is for auto-detection


class TranscriberApp(App):
    """A Textual app for interactive recording."""

    ENABLE_COMMAND_PALETTE = False

    BINDINGS = [
        ("t", "transcribe(False, False)", "Transcribe"),
        ("r", "transcribe(True, False)", "Rewrite"),
        ("c", "transcribe(True, True)", "Rewrite w/ Context"),
        ("l", "toggle_language", "Language"),
        ("p", "toggle_provider", "Audio Provider"),
        ("s", "toggle_rewrite_provider", "Rewrite Provider"),
        ("q", "quit", "Quit"),
    ]

    def __init__(self, state: AppState):
        super().__init__()
        self.state = state
        self.recording_process: subprocess.Popen | None = None
        self.ffmpeg_log_handle = None

    def compose(self) -> ComposeResult:
        yield Static(id="info_file")
        yield Static(id="info_stats")
        yield Static(id="info_provider")
        yield Static(id="info_rewrite_provider")
        yield Static(id="info_language")
        yield Static()  # Spacer
        yield Footer()

    def on_mount(self) -> None:
        """Start the recording and the UI timer."""
        # Set the static file path line
        file_info_widget = self.query_one("#info_file", Static)
        file_info_text = Text("Recording to ")
        file_info_text.append(str(self.state.output_file.resolve()), style="cyan")
        file_info_widget.update(file_info_text)

        # Set the initial provider line and start the stats timer
        self.update_provider_display()
        self.update_rewrite_provider_display()
        self.update_language_display()
        self.update_timer = self.set_interval(1 / 10, self.update_stats)
        self.start_recording()

    def update_stats(self) -> None:
        """Update the stats display and check for recording process failure."""
        if self.recording_process and self.recording_process.poll() is not None:
            # The recording process has terminated unexpectedly.
            if self.ffmpeg_log_handle:
                self.ffmpeg_log_handle.close()
                self.ffmpeg_log_handle = None

            log_path = self.state.output_file.with_suffix(".log")
            error_message = f"Recording process failed. See log: {log_path}"
            self.exit(RecordingError(error_message))

        stats_widget = self.query_one("#info_stats", Static)
        stats_text = Text("Stats: ")
        stats_text.append(f"{self.state.get_duration()} | {self.state.get_file_size_str()}")
        stats_widget.update(stats_text)

    def update_provider_display(self) -> None:
        """Update the provider display."""
        provider_widget = self.query_one("#info_provider", Static)
        provider_text = Text("Audio Provider: ")
        provider_text.append(self.state.provider.capitalize(), style="green")
        provider_widget.update(provider_text)

    def update_rewrite_provider_display(self) -> None:
        """Update the rewrite provider display."""
        provider_widget = self.query_one("#info_rewrite_provider", Static)
        provider_text = Text("Rewrite Provider: ")
        provider_text.append(self.state.rewrite_provider, style="magenta")
        provider_widget.update(provider_text)

    def update_language_display(self) -> None:
        """Update the language display."""
        language_widget = self.query_one("#info_language", Static)
        lang_text = self.state.language if self.state.language else "auto"
        language_display_text = Text("Language: ")
        language_display_text.append(lang_text, style="blue")
        language_widget.update(language_display_text)

    def start_recording(self):
        """Starts the ffmpeg recording process, capturing stderr for error reporting."""
        log_path = self.state.output_file.with_suffix(".log")
        self.ffmpeg_log_handle = log_path.open("w", encoding="utf-8")
        ffmpeg_cmd = [
            "ffmpeg",
            "-f",
            "alsa",
            "-i",
            "default",
            "-acodec",
            "libmp3lame",
            "-ab",
            "128k",
            "-y",
            str(self.state.output_file),
        ]
        # Capture stderr to detect errors if the process fails during recording
        self.recording_process = subprocess.Popen(
            ffmpeg_cmd,
            stdout=self.ffmpeg_log_handle,
            stderr=self.ffmpeg_log_handle,
        )

    def stop_recording(self):
        """Stops the ffmpeg recording process."""
        if self.recording_process and self.recording_process.poll() is None:
            self.recording_process.terminate()

            # Optimisation: we delay the import of litellm as it delays a lot the start of the script
            # until we can record. But here, ffmpeg needs a bit of time to stop (writing audio buffer to disk)
            # so it's a good time to do something else that takes ~1s.
            import litellm

            # It's a long timeout, but we want to be sure have everything written to disk
            # in practice, the timeout should not be reached.
            self.recording_process.wait(timeout=15)
            if self.recording_process.poll() is None:  # Force kill if terminate fails
                self.recording_process.kill()

        if self.ffmpeg_log_handle:
            self.ffmpeg_log_handle.close()
            self.ffmpeg_log_handle = None

    def action_transcribe(self, rewrite: bool, with_context: bool) -> None:
        """Stop recording and exit the app to transcribe."""
        self.state.rewrite = rewrite
        self.state.with_context = with_context
        self.stop_recording()
        self.exit(self.state)

    def action_toggle_provider(self) -> None:
        """Toggle the transcription provider."""
        providers = list(TRANSCRIPTION_PROVIDERS.keys())
        current_index = providers.index(self.state.provider)
        next_index = (current_index + 1) % len(providers)
        self.state.provider = providers[next_index]
        self.update_provider_display()

    def action_toggle_rewrite_provider(self) -> None:
        """Toggle the rewrite provider."""
        providers = list(REWRITE_PROVIDERS.keys())
        current_index = providers.index(self.state.rewrite_provider)
        next_index = (current_index + 1) % len(providers)
        self.state.rewrite_provider = providers[next_index]
        self.update_rewrite_provider_display()

    def action_toggle_language(self) -> None:
        """Toggle the transcription language."""
        try:
            current_index = LANGUAGES.index(self.state.language)
            next_index = (current_index + 1) % len(LANGUAGES)
        except ValueError:
            next_index = 0  # Default to first language if current is not in list
        self.state.language = LANGUAGES[next_index]
        self.update_language_display()

    def action_quit(self) -> None:
        """Quit the application without transcribing."""
        self.stop_recording()
        self.exit(None)


# --- Core Logic ---
def take_screenshot() -> bytes | None:
    """
    Takes a screenshot using available system tools or MSS.
    Returns image bytes on success, None on failure.
    """
    temp_path = Path(tempfile.gettempdir()) / f"2text-screenshot-{time.time()}.png"

    # Try Wayland's grim
    if "WAYLAND_DISPLAY" in os.environ and shutil.which("grim"):
        try:
            subprocess.run(["grim", str(temp_path)], check=True, capture_output=True)
            with open(temp_path, "rb") as f:
                return f.read()
        except (subprocess.CalledProcessError, FileNotFoundError):
            pass  # Fall through to next method
        finally:
            if temp_path.exists():
                temp_path.unlink()

    # Try X11's scrot
    if "WAYLAND_DISPLAY" not in os.environ and shutil.which("scrot"):
        try:
            # -z: silent, -q 0: no quality warning
            subprocess.run(
                ["scrot", "-z", "-q", "0", str(temp_path)],
                check=True,
                capture_output=True,
            )
            with open(temp_path, "rb") as f:
                return f.read()
        except (subprocess.CalledProcessError, FileNotFoundError):
            pass  # Fall through to next method
        finally:
            if temp_path.exists():
                temp_path.unlink()

    # Fallback to MSS
    import mss

    try:

        with mss.mss() as sct:
            sct_img = sct.grab(sct.monitors[1])  # Grab the first monitor
            return mss.tools.to_png(sct_img.rgb, sct_img.size)
    except Exception:
        return None  # Other MSS errors


def copy_to_clipboard(text: str):
    """Copies the given text to the system clipboard."""
    if os.environ.get("WAYLAND_DISPLAY"):
        cmd = ["wl-copy"]
    else:
        cmd = ["xclip", "-selection", "clipboard"]
    subprocess.run(cmd, input=text, encoding="utf-8")


def rewrite_transcript(
    console: Console, transcript: str, model_name: str, image_bytes: bytes | None = None
) -> str:
    """Rewrites the transcript using an LLM for clarity and formatting."""
    # litellm is slow to import at the start of the script, so we delay it
    from litellm import completion

    console.print("‚úçÔ∏è  Rewriting transcript...", end="")
    rewrite_start = time.time()
    system_prompt = (
        "You are an expert editor. Your sole task is to silently correct the following text. "
        "Fix any transcription errors, punctuation, and capitalization. Format it into clean paragraphs. "
        "You may be provided with an image as context. Use it to improve the accuracy of the transcription, for spelling of names, technical terms, or code. "
        "**Only output the corrected text.** Do not add comments, explanations, or any meta-text. "
        "The output should be a clean, corrected version of the original text, ready to be copied and pasted directly."
    )

    messages = [{"role": "system", "content": system_prompt}]
    if image_bytes:
        base64_image = base64.b64encode(image_bytes).decode("utf-8")
        user_text = f"Please correct and format this transcript. Use the attached screenshot for context (e.g., for spelling of names, technical terms, etc.).\n\n---\n\n<transcript>\n{transcript}\n</transcript>"
        user_content = [
            {
                "type": "image_url",
                "image_url": {"url": f"data:image/png;base64,{base64_image}"},
            },
            {"type": "text", "text": user_text},
        ]
    else:
        user_content = transcript

    messages.append({"role": "user", "content": user_content})

    response = completion(
        model=model_name,
        messages=messages,
    )
    rewritten_text = response.choices[0].message.content.strip()
    rewrite_duration = time.time() - rewrite_start
    console.print(f" {rewrite_duration:.2f}s ‚úì")
    return rewritten_text


def transcribe_audio(
    console: Console, file_path: Path, state: AppState, context_image: bytes | None = None
):
    """Handles the transcription process and prints the result."""
    # litellm is slow to import at the start of the script, so we delay it
    from litellm import transcription

    console.print(f"üé§ Transcribing with [bold]{state.provider}[/bold]...", end="")
    transcribe_start = time.time()

    with open(file_path, "rb") as audio_file:
        response = transcription(
            model=state.model_name,
            file=audio_file,
            language=state.language,
        )
    text = response["text"].strip()
    transcribe_duration = time.time() - transcribe_start
    console.print(f" {transcribe_duration:.2f}s ‚úì")

    if state.rewrite:
        image_bytes_for_rewrite = context_image
        rewrite_provider_key = state.rewrite_provider
        rewrite_provider_config = REWRITE_PROVIDERS[rewrite_provider_key]
        model_for_rewrite = rewrite_provider_config["model"]

        # Handle context request
        if state.with_context:
            if not image_bytes_for_rewrite:
                # This handles interactive mode where we need to take a screenshot
                image_bytes_for_rewrite = take_screenshot()
                if not image_bytes_for_rewrite:
                    console.print("[bold red]Error: Failed to take a screenshot.[/bold red]")

            if image_bytes_for_rewrite and not rewrite_provider_config["supports_images"]:
                # Smart fallback
                original_provider = rewrite_provider_key
                # Find the first available provider that supports images
                for provider_key, config in REWRITE_PROVIDERS.items():
                    if config["supports_images"]:
                        rewrite_provider_key = provider_key
                        model_for_rewrite = config["model"]
                        break
                console.print(
                    f"[bold yellow]Notice:[/bold yellow] '{original_provider}' does not support images. "
                    f"Temporarily switching to '{rewrite_provider_key}' for this request."
                )

        text = rewrite_transcript(console, text, model_for_rewrite, image_bytes_for_rewrite)

    console.print(f"\n[bold]Transcript:[/bold]\n{text}")

    copy_to_clipboard(text)
    console.print("\n[dim]Transcript copied to clipboard.[/dim]")


def check_dependencies(console: Console):
    """Checks for required tools and filters providers based on available API keys."""
    global TRANSCRIPTION_PROVIDERS, REWRITE_PROVIDERS

    # Check for ffmpeg
    if not shutil.which("ffmpeg"):
        console.print("[bold red]Error: ffmpeg not found.[/bold red]")
        console.print("Please install ffmpeg and ensure it's in your system's PATH.")
        console.print("  - On Debian/Ubuntu: sudo apt update && sudo apt install ffmpeg")
        console.print("  - On macOS (with Homebrew): brew install ffmpeg")
        raise typer.Exit(code=1)

    # Dynamically filter providers based on available API keys
    def filter_providers(providers: dict) -> dict:
        """Removes providers for which the API key is not set."""
        return {
            key: config
            for key, config in providers.items()
            if os.environ.get(config["api_key_env"])
        }

    transcription_keys = set(config["api_key_env"] for config in TRANSCRIPTION_PROVIDERS.values())
    rewrite_keys = set(config["api_key_env"] for config in REWRITE_PROVIDERS.values())
    TRANSCRIPTION_PROVIDERS = filter_providers(TRANSCRIPTION_PROVIDERS)
    REWRITE_PROVIDERS = filter_providers(REWRITE_PROVIDERS)

    if not TRANSCRIPTION_PROVIDERS:
        console.print("[bold red]Error: No transcription providers could be configured.[/bold red]")
        console.print(f"Please set at least one API key ({', '.join(transcription_keys)}).")
        raise typer.Exit(1)
    if not REWRITE_PROVIDERS:
        console.print("[bold red]Error: No rewrite providers could be configured.[/bold red]")
        console.print(f"Please set at least one API key ({', '.join(rewrite_keys)}).")
        raise typer.Exit(1)


# --- Main Application ---
def main(
    file: str | None = typer.Argument(None, help="Path to an audio file to transcribe directly."),
    language: str = typer.Option(
        None,
        "-l",
        "--language",
        help="Language of the audio. If not provided, the language will be detected automatically.",
    ),
    provider: str = typer.Option(
        None, "--provider", help="API provider to use. Overrides saved setting."
    ),
    rewrite: bool = typer.Option(
        False, "--rewrite", help="Rewrite the transcript for clarity (non-interactive mode only)."
    ),
    context_image: Path = typer.Option(
        None,
        "--context-image",
        help="Path to an image file to use as context for rewriting.",
        exists=True,
        file_okay=True,
        dir_okay=False,
        readable=True,
    ),
):
    """
    An interactive audio recorder and transcriber.
    Run without arguments to start an interactive recording session.
    """
    console = Console()
    check_dependencies(console)

    temp_dir = Path(tempfile.gettempdir())

    # --- Non-Interactive (File-based) Mode ---
    if file:
        image_bytes = None
        if context_image:
            if not rewrite:
                console.print(
                    "[bold yellow]Warning:[/bold yellow] --context-image is provided but --rewrite is not. The image will be ignored."
                )
            else:
                with open(context_image, "rb") as f:
                    image_bytes = f.read()

        # Use dataclass defaults, overridden only by CLI args. No config file.
        state = AppState(rewrite=rewrite, with_context=bool(image_bytes))
        if provider:
            state.provider = provider
        if language:
            state.language = language

        if file.upper() == "LAST":
            recordings = sorted(temp_dir.glob("recording-*.mp3"))
            if not recordings:
                console.print(f"[red]Error: No 'LAST' recording found in {temp_dir}.[/red]")
                raise typer.Exit(1)
            audio_file_path = recordings[-1]
            console.print(f"Using last recording: [cyan]{audio_file_path}[/cyan]")
        else:
            audio_file_path = Path(file)

        if not audio_file_path.exists():
            console.print(f"[red]Error: File not found: {audio_file_path}[/red]")
            raise typer.Exit(1)

        transcribe_audio(console, audio_file_path, state, context_image=image_bytes)
        return

    # --- Interactive Mode ---
    # Load saved settings and override with any CLI args
    saved_settings = load_settings()
    if provider:
        saved_settings["provider"] = provider
    if language:
        saved_settings["language"] = language
    state = AppState(**saved_settings)
    state.output_file = temp_dir / f"recording-{time.strftime('%Y-%m-%d-%H-%M-%S')}.mp3"

    app = TranscriberApp(state)
    final_state = app.run()

    console.clear()
    if isinstance(final_state, RecordingError):
        console.print(final_state, markup=False)
        console.print("[bold red]‚ùå Recording failed unexpectedly.[/bold red]")
        raise typer.Exit(1)

    elif final_state:
        console.print(f"‚úÖ Recording finished. File: [cyan]{final_state.output_file}[/cyan]")
        save_settings(final_state)
        transcribe_audio(console, final_state.output_file, final_state)
    else:
        console.print(f"‚ùå Recording cancelled. File: [cyan]{state.output_file}[/cyan]")


if __name__ == "__main__":
    typer.run(main)
