#!/usr/bin/env python

"""
An interactive audio recorder and transcriber with an optional rewrite step.

Records audio and transcribes it using a selected provider (Groq or OpenAI).
- In interactive mode, it shows a live UI to control recording and options.
- In non-interactive mode, it transcribes a given audio file.
- Optionally rewrites the transcript for clarity and formatting using an LLM.
"""
import os
import shutil
import subprocess
import time
import json
from dataclasses import dataclass, field
from pathlib import Path

import typer
from rich.console import Console
from rich.text import Text
import platformdirs

from textual.app import App, ComposeResult
from textual.widgets import Footer, Header, Static

from dotenv import load_dotenv


# --- Settings Management ---
def get_settings_path() -> Path:
    """Returns the path to the settings file."""
    settings_dir = platformdirs.user_config_path("2text", ensure_exists=True)
    return settings_dir / "settings.json"


def load_settings() -> dict:
    """Loads settings from the JSON file, returning an empty dict on failure."""
    settings_path = get_settings_path()
    if not settings_path.exists():
        return {}
    try:
        with open(settings_path, "r") as f:
            # Handle empty file case
            content = f.read()
            if not content:
                return {}
            return json.loads(content)
    except (json.JSONDecodeError, IOError):
        return {}


def save_settings(state: "AppState"):
    """Saves relevant settings from the app state to the JSON file."""
    settings_path = get_settings_path()
    settings_to_save = {"provider": state.provider, "language": state.language}
    with open(settings_path, "w") as f:
        json.dump(settings_to_save, f, indent=2)


# --- State Management ---
@dataclass
class AppState:
    """Holds the dynamic state of the application."""

    provider: str = "groq"
    language: str | None = "auto"
    rewrite: bool = False
    output_file: Path | None = None
    start_time: float = field(default_factory=time.time)

    @property
    def model_name(self) -> str:
        """Returns the transcription model name based on the provider."""
        if self.provider == "openai":
            return "openai/whisper-1"
        return "groq/whisper-large-v3"

    def get_duration(self) -> str:
        """Returns the formatted recording duration."""
        return f"{time.time() - self.start_time:.1f}s"

    def get_file_size_str(self) -> str:
        """Returns the formatted file size as a string."""
        if self.output_file and self.output_file.exists():
            size_bytes = self.output_file.stat().st_size
            if size_bytes < 1024:
                return f"{size_bytes} B"
            elif size_bytes < 1024 * 1024:
                return f"{size_bytes / 1024:.1f} KB"
            else:
                return f"{size_bytes / (1024 * 1024):.1f} MB"
        return "0 B"


# --- Textual Application for Interactive Mode ---
LANGUAGES = ["en", "fr", None]  # None is for auto-detection


class TranscriberApp(App):
    """A Textual app for interactive recording."""

    ENABLE_COMMAND_PALETTE = False

    BINDINGS = [
        ("t", "transcribe(False)", "Transcribe"),
        ("r", "transcribe(True)", "Rewrite"),
        ("l", "toggle_language", "Language"),
        ("p", "toggle_provider", "Provider"),
        ("q", "quit", "Quit"),
    ]

    def __init__(self, state: AppState):
        super().__init__()
        self.state = state
        self.recording_process: subprocess.Popen | None = None

    def compose(self) -> ComposeResult:
        yield Static(id="info_file")
        yield Static(id="info_stats")
        yield Static(id="info_provider")
        yield Static(id="info_language")
        yield Static()  # Spacer
        yield Footer()

    def on_mount(self) -> None:
        """Start the recording and the UI timer."""
        # Set the static file path line
        file_info_widget = self.query_one("#info_file", Static)
        file_info_text = Text("Recording to ")
        file_info_text.append(str(self.state.output_file.resolve()), style="cyan")
        file_info_widget.update(file_info_text)

        # Set the initial provider line and start the stats timer
        self.update_provider_display()
        self.update_language_display()
        self.update_timer = self.set_interval(1 / 10, self.update_stats)
        self.start_recording()

    def update_stats(self) -> None:
        """Update the stats display."""
        try:
            stats_widget = self.query_one("#info_stats", Static)
            stats_text = Text("Stats: ")
            stats_text.append(
                f"Duration: {self.state.get_duration()} | Size: {self.state.get_file_size_str()}"
            )
            stats_widget.update(stats_text)
        except Exception:
            pass  # Can happen during shutdown

    def update_provider_display(self) -> None:
        """Update the provider display."""
        try:
            provider_widget = self.query_one("#info_provider", Static)
            provider_text = Text("Provider: ")
            provider_text.append(self.state.provider.capitalize(), style="green")
            provider_widget.update(provider_text)
        except Exception:
            pass

    def update_language_display(self) -> None:
        """Update the language display."""
        try:
            language_widget = self.query_one("#info_language", Static)
            lang_text = self.state.language if self.state.language else "auto"
            language_display_text = Text("Language: ")
            language_display_text.append(lang_text, style="blue")
            language_widget.update(language_display_text)
        except Exception:
            pass

    def start_recording(self):
        """Starts the ffmpeg recording process."""
        ffmpeg_cmd = [
            "ffmpeg",
            "-f",
            "alsa",
            "-i",
            "default",
            "-acodec",
            "libmp3lame",
            "-ab",
            "128k",
            "-y",
            str(self.state.output_file),
        ]
        self.recording_process = subprocess.Popen(
            ffmpeg_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
        )

    def stop_recording(self):
        """Stops the ffmpeg recording process."""
        if self.recording_process and self.recording_process.poll() is None:
            self.recording_process.terminate()
            self.recording_process.wait(timeout=2)
            if self.recording_process.poll() is None:  # Force kill if terminate fails
                self.recording_process.kill()

    def action_transcribe(self, rewrite: bool) -> None:
        """Stop recording and exit the app to transcribe."""
        self.state.rewrite = rewrite
        self.stop_recording()
        self.exit(self.state)

    def action_toggle_provider(self) -> None:
        """Toggle the transcription provider."""
        self.state.provider = "openai" if self.state.provider == "groq" else "groq"
        self.update_provider_display()

    def action_toggle_language(self) -> None:
        """Toggle the transcription language."""
        try:
            current_index = LANGUAGES.index(self.state.language)
            next_index = (current_index + 1) % len(LANGUAGES)
        except ValueError:
            next_index = 0  # Default to first language if current is not in list
        self.state.language = LANGUAGES[next_index]
        self.update_language_display()

    def action_quit(self) -> None:
        """Quit the application without transcribing."""
        self.stop_recording()
        self.exit(None)


# --- Core Logic ---
def copy_to_clipboard(text: str):
    """Copies the given text to the system clipboard."""
    if os.environ.get("WAYLAND_DISPLAY"):
        cmd = ["wl-copy"]
    else:
        cmd = ["xclip", "-selection", "clipboard"]
    subprocess.run(cmd, input=text, encoding="utf-8")


def rewrite_transcript(console: Console, transcript: str) -> str:
    """Rewrites the transcript using an LLM for clarity and formatting."""
    from litellm import completion

    console.print("‚úçÔ∏è  Rewriting transcript...", end="")
    rewrite_start = time.time()
    system_prompt = (
        "You are an expert editor. Your sole task is to silently correct the following text. "
        "Fix any transcription errors, punctuation, and capitalization. Format it into clean paragraphs. "
        "**Only output the corrected text.** Do not add comments, explanations, or any meta-text. "
        "The output should be a clean, corrected version of the original text, ready to be copied and pasted directly."
    )

    response = completion(
        model="groq/llama3-70b-8192",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": transcript},
        ],
    )
    rewritten_text = response.choices[0].message.content.strip()
    rewrite_duration = time.time() - rewrite_start
    console.print(f" {rewrite_duration:.2f}s ‚úì")
    return rewritten_text


def transcribe_audio(console: Console, file_path: Path, state: AppState):
    """Handles the transcription process and prints the result."""
    from dotenv import load_dotenv
    from litellm import transcription

    load_dotenv()

    console.print(f"üé§ Transcribing with [bold]{state.provider}[/bold]...", end="")
    transcribe_start = time.time()

    with open(file_path, "rb") as audio_file:
        response = transcription(
            model=state.model_name,
            file=audio_file,
            language=state.language,
        )
    text = response["text"].strip()
    transcribe_duration = time.time() - transcribe_start
    console.print(f" {transcribe_duration:.2f}s ‚úì")

    if state.rewrite:
        text = rewrite_transcript(console, text)

    console.print(f"\n[bold]Transcript:[/bold]\n{text}")

    copy_to_clipboard(text)
    console.print("\n[dim]Transcript copied to clipboard.[/dim]")


def check_dependencies(console: Console):
    """Checks for required command-line tools and API keys."""
    load_dotenv()

    # Check for ffmpeg
    if not shutil.which("ffmpeg"):
        console.print("[bold red]Error: ffmpeg not found.[/bold red]")
        console.print("Please install ffmpeg and ensure it's in your system's PATH.")
        console.print("  - On Debian/Ubuntu: sudo apt update && sudo apt install ffmpeg")
        console.print("  - On macOS (with Homebrew): brew install ffmpeg")
        raise typer.Exit(code=1)

    # Check for API keys
    if not os.environ.get("GROQ_API_KEY") and not os.environ.get("OPENAI_API_KEY"):
        console.print("[bold red]Error: API key not found.[/bold red]")
        console.print("Please set either GROQ_API_KEY or OPENAI_API_KEY in your environment.")
        console.print("You can add them to a `.env` file in the project root.")
        raise typer.Exit(code=1)


# --- Main Application ---
def main(
    file: str | None = typer.Argument(None, help="Path to an audio file to transcribe directly."),
    language: str = typer.Option(
        None,
        "-l",
        "--language",
        help="Language of the audio. If not provided, the language will be detected automatically.",
    ),
    provider: str = typer.Option(
        None, "--provider", help="API provider to use. Overrides saved setting."
    ),
    rewrite: bool = typer.Option(
        False, "--rewrite", help="Rewrite the transcript for clarity (non-interactive mode only)."
    ),
):
    """
    An interactive audio recorder and transcriber.
    Run without arguments to start an interactive recording session.
    """
    console = Console()
    check_dependencies(console)

    # --- Non-Interactive (File-based) Mode ---
    if file:
        # Use dataclass defaults, overridden only by CLI args. No config file.
        state = AppState(rewrite=rewrite)
        if provider:
            state.provider = provider
        if language:
            state.language = language

        if file.upper() == "LAST":
            recordings = sorted(Path("/tmp").glob("recording-*.mp3"))
            if not recordings:
                console.print("[red]Error: No 'LAST' recording found in /tmp.[/red]")
                raise typer.Exit(1)
            audio_file_path = recordings[-1]
            console.print(f"Using last recording: [cyan]{audio_file_path}[/cyan]")
        else:
            audio_file_path = Path(file)

        if not audio_file_path.exists():
            console.print(f"[red]Error: File not found: {audio_file_path}[/red]")
            raise typer.Exit(1)

        transcribe_audio(console, audio_file_path, state)
        return

    # --- Interactive Mode ---
    # Load saved settings and override with any CLI args
    saved_settings = load_settings()
    if provider:
        saved_settings["provider"] = provider
    if language:
        saved_settings["language"] = language
    state = AppState(**saved_settings)
    state.output_file = Path(f"/tmp/recording-{time.strftime('%Y-%m-%d-%H-%M-%S')}.mp3")

    app = TranscriberApp(state)
    final_state = app.run(inline=True)

    console.clear()
    if final_state:
        console.print(f"‚úÖ Recording finished. File: [cyan]{final_state.output_file}[/cyan]")
        save_settings(final_state)
        transcribe_audio(console, final_state.output_file, final_state)
    else:
        console.print(f"‚ùå Recording cancelled. File: [cyan]{state.output_file}[/cyan]")


if __name__ == "__main__":
    typer.run(main)
